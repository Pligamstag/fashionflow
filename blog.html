<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FashionFlow - Blog</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --accent: #06b6d4;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #0f172a;
            --dark-secondary: #1e293b;
            --text-light: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--dark) 0%, var(--dark-secondary) 100%);
            color: var(--text-light);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        .background-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .bg-circle {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
            filter: blur(40px);
            animation: float 6s ease-in-out infinite;
        }

        .bg-circle:nth-child(1) {
            width: 400px;
            height: 400px;
            top: -200px;
            right: -200px;
            animation-delay: 0s;
        }

        .bg-circle:nth-child(2) {
            width: 300px;
            height: 300px;
            bottom: -150px;
            left: -150px;
            animation-delay: 2s;
        }

        .bg-circle:nth-child(3) {
            width: 200px;
            height: 200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation-delay: 4s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
            }
            50% {
                transform: translateY(-20px) rotate(180deg);
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            position: relative;
            z-index: 1;
        }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 0;
            margin-bottom: 40px;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-actions {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .hero {
            text-align: center;
            margin-bottom: 60px;
            padding: 60px 0;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .posts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .posts-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-light);
        }

        .search-filter {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .search-box {
            position: relative;
        }

        .search-input {
            padding: 12px 50px 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            width: 300px;
            backdrop-filter: blur(10px);
            font-size: 0.9rem;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
        }

        .posts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 60px;
        }

        .post-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .post-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
        }

        .post-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .author-avatar, .comment-avatar, .user-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            color: white;
            object-fit: cover; /* Ensure image covers the circle */
            flex-shrink: 0; /* Prevent avatar from shrinking */
        }

        .post-meta {
            flex: 1;
        }

        .post-author {
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 5px;
        }

        .post-date {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
        }

        .post-title {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-light);
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .post-content {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
            margin-bottom: 25px;
            font-size: 0.95rem;
        }

        .post-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.8rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            text-decoration: none;
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: translateY(-1px);
        }

        .like-btn {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .like-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: translateY(-1px);
        }

        .like-btn.liked {
            animation: likeAnimation 0.6s ease;
            color: var(--danger); /* Change color when liked */
            border-color: var(--danger);
            background: rgba(239, 68, 68, 0.3);
        }

        @keyframes likeAnimation {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }

        .btn-info {
            background: rgba(6, 182, 212, 0.1);
            color: #67e8f9;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .btn-info:hover {
            background: rgba(6, 182, 212, 0.2);
            transform: translateY(-1px);
        }

        .comments-section {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 20px;
            margin-top: 30px;
        }

        .comments-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-light);
        }

        .comment-form-main-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .comment-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .comment-textarea {
            width: 100%;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(10px);
            font-size: 0.95rem;
        }

        .comment-textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .comment-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .comment-submit-btn {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--success), #059669);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .comment-submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .comment-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-radius: 12px;
            border-left: 3px solid var(--accent);
            backdrop-filter: blur(10px);
        }

        .comment-item.reply {
            margin-left: 30px;
            border-left: 3px solid var(--secondary);
            background: rgba(255, 255, 255, 0.03);
        }

        .comment-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .comment-meta {
            flex: 1;
        }

        .comment-author-name {
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .reply-to-text {
            font-weight: normal;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .comment-date {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
        }

        .comment-content {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .comment-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .comment-actions .action-btn {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .comment-actions .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .comment-actions .delete-comment-btn {
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.1);
        }

        .comment-actions .delete-comment-btn:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .reply-form-container {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            animation: slideDown 0.3s ease;
        }

        .reply-form-actual {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .reply-form-actual .comment-textarea {
            min-height: 60px;
            padding: 10px;
        }

        .reply-form-actual .btn {
            align-self: flex-end;
        }

        .replies-list-nested {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .empty-state, .info-message {
            text-align: center;
            padding: 80px 20px;
            color: rgba(255, 255, 255, 0.8);
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 60px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1rem;
        }

        .loading i {
            margin-right: 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        /* Styles for the notification popup */
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            animation: fadeInOut 3s forwards;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            10% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            90% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-light);
            font-weight: 600;
        }

        .profile-actions {
            display: flex;
            gap: 10px;
            margin-left: 20px;
        }

        /* Modal styles */
        #loginModal, #editProfileModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        #loginModal > div, #editProfileModal > div {
            background: var(--dark-secondary);
            padding: 40px;
            border-radius: 12px;
            max-width: 400px;
            width: 100%;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        #loginModal h2, #editProfileModal h3 {
            margin-bottom: 20px;
            color: var(--primary);
            text-align: center;
        }

        #loginForm, #editProfileForm {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #loginForm input, #editProfileForm input {
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-light);
            font-size: 0.95rem;
        }

        #loginForm input::placeholder, #editProfileForm input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #loginForm input:focus, #editProfileForm input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
        }

        #loginModal .btn, #editProfileModal .btn {
            width: 100%;
            justify-content: center;
            margin-top: 5px; /* Adjust margin for buttons in modal */
        }

        #loginModal #cancelLogin, #editProfileModal #cancelEditProfile {
            position: absolute;
            top: 15px;
            right: 15px;
            width: auto;
            padding: 8px 12px;
            font-size: 1rem;
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 50%; /* Make it circular */
        }

        #loginModal #cancelLogin:hover, #editProfileModal #cancelEditProfile:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        #editProfileForm label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-top: 10px;
        }
        #editProfileForm input[type="file"] {
            padding: 8px;
        }


        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }

            .navbar {
                flex-direction: column;
                gap: 15px;
                padding: 20px;
            }

            .posts-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .post-card {
                padding: 24px;
            }

            .hero h1 {
                font-size: 2.5rem;
            }

            .posts-header {
                flex-direction: column;
                align-items: stretch;
            }

            .search-input {
                width: 100%;
            }

            .post-actions {
                justify-content: stretch;
            }

            .btn-small {
                flex: 1;
                justify-content: center;
            }

            .comment-item.reply {
                margin-left: 15px; /* Adjust for smaller screens */
            }

            #loginModal > div, #editProfileModal > div {
                padding: 25px;
            }
        }
    </style>
</head>
<body>
<div id="loginModal">
    <div>
        <h2>Connexion</h2>
        <form id="loginForm">
            <input id="email" type="email" placeholder="Email" required>
            <input id="password" type="password" placeholder="Mot de passe" required>
            <button type="submit" class="btn btn-primary">Se connecter</button>
        </form>
        <button id="registerBtn" class="btn btn-secondary">Créer un compte</button>
        <button id="googleLoginBtn" class="btn btn-info">Se connecter avec Google</button>
        <button id="cancelLogin" class="btn btn-danger">X</button>
    </div>
</div>
<div id="editProfileModal">
    <div>
        <h3>Modifier le profil</h3>
        <form id="editProfileForm">
            <input id="displayNameInput" type="text" placeholder="Nouveau nom">
            <label for="photoFileInput">Importer une photo de profil :</label>
            <input id="photoFileInput" type="file" accept="image/*">
            <button type="submit" class="btn btn-success">Enregistrer</button>
            <button type="button" id="cancelEditProfile" class="btn btn-danger">X</button>
        </form>
    </div>
</div>


<div class="background-effects">
    <div class="bg-circle"></div>
    <div class="bg-circle"></div>
    <div class="bg-circle"></div>
</div>

<div class="container">
    <nav class="navbar">
        <a href="#" class="logo">
            <i class="fas fa-blog"></i>
            FashionFlow
        </a>
        <div class="nav-actions">
            <a href="creerunposte.html" class="btn btn-primary" id="newPostBtn" style="display: none;">
                <i class="fas fa-plus"></i>
                Nouveau post
            </a>
            <a href="index.html" class="btn btn-secondary">
                <i class="fas fa-home"></i>
                Accueil
            </a>
        </div>
        <div id="userProfile" style="color: white; display: flex; align-items: center; gap: 10px;">
            </div>

        <button id="loginBtn" class="btn btn-secondary">Se connecter</button>

    </nav>

    <section class="hero">
        <h1>Blog de Développement</h1>
        <p>Partagez vos idées, découvertes et projets avec la communauté</p>
    </section>

    <div class="posts-header">
        <h2 class="posts-title">Publications récentes</h2>
        <div class="search-filter">
            <div class="search-box">
                <input type="text" class="search-input" placeholder="Rechercher des posts...">
                <i class="fas fa-search search-icon"></i>
            </div>
        </div>
    </div>

    <div id="postsContainer" class="posts-grid">
        <div class="loading">
            <i class="fas fa-spinner"></i>
            Chargement des publications...
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import {
    getAuth,
    GoogleAuthProvider,
    signInWithPopup,
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    signOut,
    onAuthStateChanged,
    updateProfile
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
import {
    getFirestore,
    collection,
    doc,
    getDoc,
    updateDoc,
    addDoc,
    deleteDoc,
    query,
    where,
    orderBy,
    getDocs,
    serverTimestamp,
    arrayUnion,
    arrayRemove,
    onSnapshot,
    setDoc // Needed for setDoc to create user profiles
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-storage.js";

// Configuration Firebase
const firebaseConfig = {
    apiKey: "YOUR_API_KEY", // Remplacez par votre clé API
    authDomain: "YOUR_AUTH_DOMAIN", // Remplacez par votre domaine d'authentification
    projectId: "YOUR_PROJECT_ID", // Remplacez par votre ID de projet
    storageBucket: "YOUR_STORAGE_BUCKET", // Remplacez par votre bucket de stockage
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Remplacez par votre ID d'expéditeur de messages
    appId: "YOUR_APP_ID", // Remplacez par votre ID d'application
    measurementId: "YOUR_MEASUREMENT_ID" // Optionnel
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const postsCol = collection(db, "devloppement"); // Collection pour les posts
const commentsCol = collection(db, "comments"); // Collection pour les commentaires
const usersCol = collection(db, "users"); // Nouvelle collection pour les profils utilisateurs (bio, etc.)
const storage = getStorage(app);

const auth = getAuth();
let currentUser = null;

// ATTENTION : Ce mot de passe ADMIN_PASSWORD NE DOIT JAMAIS être codé en dur en production côté client.
// Utilisez Firebase Cloud Functions ou un service backend sécurisé pour cela.
const ADMIN_PASSWORD = "FFLFKSprod"; // Remplacez par votre mot de passe admin pour le développement, mais sécurisez-le !

// Références aux éléments du DOM
const postsContainer = document.getElementById("postsContainer");
const loginModal = document.getElementById("loginModal");
const loginBtn = document.getElementById("loginBtn");
const userProfile = document.getElementById("userProfile");
const googleLoginBtn = document.getElementById('googleLoginBtn');
const registerBtn = document.getElementById('registerBtn');
const cancelLogin = document.getElementById('cancelLogin');
const loginForm = document.getElementById('loginForm');
const newPostBtn = document.getElementById('newPostBtn');

// Éléments pour le nouveau Modal d'affichage de profil
const profileViewerModal = document.getElementById('profileViewerModal');
const cancelProfileViewer = document.getElementById('cancelProfileViewer');
const myPostsTab = document.getElementById('myPostsTab');
const myLikesTab = document.getElementById('myLikesTab');
const myPostsContent = document.getElementById('myPostsContent');
const myLikesContent = document.getElementById('myLikesContent');
const userPostsContainer = document.getElementById('userPostsContainer');
const userLikesContainer = document.getElementById('userLikesContainer');
const openEditProfileFromViewer = document.getElementById('openEditProfileFromViewer');

// Éléments pour le Modal de modification de profil
const editProfileModal = document.getElementById('editProfileModal');
const editProfileForm = document.getElementById('editProfileForm');
const cancelEditProfile = document.getElementById('cancelEditProfile');
const displayNameInput = document.getElementById('displayNameInput');
const bioInput = document.getElementById('bioInput');
const photoFileInput = document.getElementById('photoFileInput');

const provider = new GoogleAuthProvider();

// Stocke les fonctions de désabonnement pour les listeners en temps réel
const commentListeners = {};
const userPostListeners = {};
const userLikedPostListeners = {};

// --- Authentification et gestion des utilisateurs ---
onAuthStateChanged(auth, (user) => {
    if (user) {
        currentUser = user;
        updateUserProfileUI(user);
        newPostBtn.style.display = 'inline-flex';
        loadPosts();
    } else {
        // Nettoyage des listeners actifs lors de la déconnexion
        for (const postId in commentListeners) {
            if (typeof commentListeners[postId] === 'function') {
                commentListeners[postId]();
                delete commentListeners[postId];
            }
        }
        for (const listenerKey in userPostListeners) {
            if (typeof userPostListeners[listenerKey] === 'function') {
                userPostListeners[listenerKey]();
                delete userPostListeners[listenerKey];
            }
        }
        for (const listenerKey in userLikedPostListeners) {
            if (typeof userLikedPostListeners[listenerKey] === 'function') {
                userLikedPostListeners[listenerKey]();
                delete userLikedPostListeners[listenerKey];
            }
        }

        currentUser = null;
        newPostBtn.style.display = 'none';
        updateUserProfileUI(null);
        loadPosts(); // Recharger les posts pour les invités
    }
});

// Connexion Google
googleLoginBtn.addEventListener('click', async () => {
    try {
        await signInWithPopup(auth, provider);
        loginModal.style.display = 'none';
        showNotification("✅ Connexion réussie avec Google !");
    } catch (error) {
        console.error("Erreur de connexion Google:", error);
        showNotification("🚫 Erreur de connexion : " + error.message);
    }
});

// Connexion Email/Mot de passe
loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('email').value.trim();
    const password = document.getElementById('password').value.trim();
    try {
        await signInWithEmailAndPassword(auth, email, password);
        loginModal.style.display = 'none';
        showNotification("✅ Connexion réussie !");
    } catch (error) {
        console.error("Erreur de connexion email/mdp:", error);
        showNotification("🚫 Erreur de connexion : " + error.message);
    }
});

// Inscription Email/Mot de passe
registerBtn.addEventListener('click', async () => {
    const email = document.getElementById('email').value.trim();
    const password = document.getElementById('password').value.trim();
    try {
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        // Créer un document utilisateur dans Firestore pour la bio, etc.
        await setDoc(doc(db, "users", userCredential.user.uid), {
            email: email,
            bio: "" // Initialiser la bio vide
        }, { merge: true });

        showNotification("✅ Inscription réussie !");
        loginModal.style.display = 'none';
    } catch (error) {
        console.error("Erreur d'inscription:", error);
        showNotification("🚫 Erreur d'inscription : " + error.message);
    }
});

// Ouvrir le Modal de Connexion
loginBtn.addEventListener('click', () => {
    loginModal.style.display = 'flex';
});

// Fermer le Modal de Connexion
cancelLogin.addEventListener('click', () => {
    loginModal.style.display = 'none';
});

// Mettre à jour l'interface utilisateur de l'en-tête en fonction du statut de connexion
function updateUserProfileUI(user) {
    if (user) {
        loginBtn.style.display = 'none';
        const userDisplayName = user.displayName || user.email.split('@')[0];
        const userInitial = getInitials(userDisplayName);
        const userPhoto = (user.photoURL && user.photoURL !== 'null') ? user.photoURL : `https://via.placeholder.com/40?text=${userInitial}`;

        userProfile.innerHTML = `
            <div class="user-info">
                <strong>${userDisplayName}</strong>
                <img src="${userPhoto}" alt="Avatar" class="user-avatar">
            </div>
            <div class="profile-actions">
                <button id="viewProfileBtn" class="btn btn-info btn-small">Mon Profil</button>
                <button id="logoutBtn" class="btn btn-danger btn-small">Déconnexion</button>
            </div>
        `;
        document.getElementById('logoutBtn').addEventListener('click', async () => {
            try {
                await signOut(auth);
                showNotification("✅ Déconnexion réussie.");
            } catch (error) {
                console.error("Erreur de déconnexion:", error);
                showNotification("🚫 Erreur de déconnexion : " + error.message);
            }
        });

        document.getElementById('viewProfileBtn').addEventListener('click', () => {
            openProfileViewer(user);
        });
    } else {
        userProfile.innerHTML = '';
        loginBtn.style.display = 'inline-flex';
    }
}

// Fonction utilitaire pour obtenir les initiales pour l'avatar par défaut
function getInitials(name) {
    if (!name) return 'A';
    const parts = name.split(' ');
    if (parts.length === 1 && parts[0].length > 0) {
        return parts[0][0].toUpperCase();
    }
    if (parts.length > 1) {
        const firstInitial = parts[0][0] || '';
        const lastInitial = parts[parts.length - 1][0] || '';
        return (firstInitial + lastInitial).toUpperCase();
    }
    return 'A';
}

// Afficher une notification temporaire
function showNotification(message, duration = 3000) {
    const notificationDiv = document.createElement('div');
    notificationDiv.className = 'notification';
    notificationDiv.textContent = message;
    document.body.appendChild(notificationDiv);
    setTimeout(() => {
        notificationDiv.remove();
    }, duration);
}

// --- Fonctions du Modal d'affichage de profil ---
async function openProfileViewer(user) {
    profileViewerModal.style.display = 'flex';

    // Remplir les informations utilisateur dans l'afficheur
    const viewerProfileAvatar = document.getElementById('viewer-profile-avatar');
    const viewerProfileDisplayName = document.getElementById('viewer-profile-displayname');
    const viewerProfileEmail = document.getElementById('viewer-profile-email');
    const viewerProfileBio = document.getElementById('viewer-profile-bio');

    const userDisplayName = user.displayName || user.email.split('@')[0];
    const userInitial = getInitials(userDisplayName);
    const userPhoto = (user.photoURL && user.photoURL !== 'null') ? user.photoURL : `https://via.placeholder.com/120?text=${userInitial}`;

    viewerProfileAvatar.src = userPhoto;
    viewerProfileDisplayName.textContent = userDisplayName;
    viewerProfileEmail.textContent = user.email;

    // Récupérer la bio depuis Firestore
    try {
        const userDocRef = doc(db, "users", user.uid);
        const userDocSnap = await getDoc(userDocRef);
        if (userDocSnap.exists()) {
            const userData = userDocSnap.data();
            viewerProfileBio.textContent = userData.bio || "Pas de bio pour le moment.";
        } else {
            viewerProfileBio.textContent = "Pas de bio pour le moment.";
            // Si le document utilisateur n'existe pas, le créer (pour les utilisateurs inscrits avant cette fonctionnalité)
            await setDoc(userDocRef, { bio: "" }, { merge: true });
        }
    } catch (error) {
        console.error("Erreur lors du chargement de la bio:", error);
        viewerProfileBio.textContent = "Erreur de chargement de la bio.";
    }

    // Activer l'onglet "Mes Publications" par défaut
    myPostsTab.classList.add('active');
    myLikesTab.classList.remove('active');
    myPostsContent.classList.add('active');
    myLikesContent.classList.remove('active');

    // Charger le contenu pour "Mes Publications" et "Mes J'aime"
    loadUserPosts(user.uid);
    loadUserLikedPosts(user.uid);
}

// Fermer le Modal d'affichage de profil
cancelProfileViewer.addEventListener('click', () => {
    profileViewerModal.style.display = 'none';
    // Se désabonner de tous les listeners de posts/posts aimés du profile viewer lors de la fermeture pour éviter les fuites de mémoire
    for (const listenerKey in userPostListeners) {
        if (typeof userPostListeners[listenerKey] === 'function') {
            userPostListeners[listenerKey]();
            delete userPostListeners[listenerKey];
        }
    }
    for (const listenerKey in userLikedPostListeners) {
        if (typeof userLikedPostListeners[listenerKey] === 'function') {
            userLikedPostListeners[listenerKey]();
            delete userLikedPostListeners[listenerKey];
        }
    }
});

// Changement d'onglet dans l'afficheur de profil
myPostsTab.addEventListener('click', () => {
    myPostsTab.classList.add('active');
    myLikesTab.classList.remove('active');
    myPostsContent.classList.add('active');
    myLikesContent.classList.remove('active');
});

myLikesTab.addEventListener('click', () => {
    myLikesTab.classList.add('active');
    myPostsTab.classList.remove('active');
    myLikesContent.classList.add('active');
    myPostsContent.classList.remove('active');
});

// Bouton pour ouvrir le Modal de modification de profil depuis l'afficheur
openEditProfileFromViewer.addEventListener('click', () => {
    profileViewerModal.style.display = 'none'; // Fermer l'afficheur
    editProfileModal.style.display = 'flex'; // Ouvrir le modal d'édition
    // Pré-remplir le formulaire d'édition de profil avec les données de l'utilisateur actuel
    if (currentUser) {
        displayNameInput.value = currentUser.displayName || '';
        // Récupérer la bio depuis Firestore à nouveau pour le formulaire d'édition afin de s'assurer qu'elle est à jour
        getDoc(doc(db, "users", currentUser.uid)).then(docSnap => {
            if (docSnap.exists()) {
                bioInput.value = docSnap.data().bio || '';
            } else {
                bioInput.value = '';
            }
        }).catch(error => {
            console.error("Erreur lors du chargement de la bio pour édition:", error);
            bioInput.value = '';
        });
        photoFileInput.value = ''; // Effacer l'entrée de fichier pour des raisons de sécurité
    }
});

// --- Fonctions du Modal de modification de profil ---
editProfileForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    if (!auth.currentUser) {
        showNotification("🚫 Vous devez être connecté pour modifier votre profil.");
        return;
    }

    const displayName = displayNameInput.value.trim();
    const bio = bioInput.value.trim();
    const file = photoFileInput.files[0];

    try {
        let photoURL = auth.currentUser.photoURL;
        if (file) {
            const storageRef = ref(storage, `profilePictures/${auth.currentUser.uid}/${Date.now()}_${file.name}`);
            await uploadBytes(storageRef, file);
            photoURL = await getDownloadURL(storageRef);
        }

        // Mettre à jour le profil d'authentification Firebase
        await updateProfile(auth.currentUser, {
            displayName: displayName || null,
            photoURL: photoURL
        });

        // Mettre à jour la bio dans le document utilisateur Firestore
        const userDocRef = doc(db, "users", auth.currentUser.uid);
        await updateDoc(userDocRef, {
            bio: bio
        }, { merge: true });

        showNotification('✅ Profil mis à jour !');
        editProfileModal.style.display = 'none';
        updateUserProfileUI(auth.currentUser); // Mettre à jour l'UI immédiatement après la mise à jour réussie
    } catch (error) {
        console.error("Erreur lors de la mise à jour du profil :", error);
        showNotification("🚫 Erreur lors de la mise à jour du profil : " + error.message);
    }
});

// Fermer le Modal de modification de profil
cancelEditProfile.addEventListener('click', () => {
    editProfileModal.style.display = 'none';
});

// --- Fonctionnalités des posts et commentaires ---

// Fonctionnalité de like/dislike
async function toggleLike(postId) {
    if (!currentUser) {
        showNotification("🚫 Vous devez être connecté pour liker.");
        return;
    }
    try {
        const postRef = doc(db, "devloppement", postId);
        const postDoc = await getDoc(postRef);
        if (!postDoc.exists()) {
            showNotification("🚫 Post introuvable !");
            return;
        }
        const postData = postDoc.data();
        const currentLikes = postData.likes || [];
        const hasLiked = currentLikes.includes(currentUser.uid);
        if (hasLiked) {
            await updateDoc(postRef, { likes: arrayRemove(currentUser.uid) });
        } else {
            await updateDoc(postRef, { likes: arrayUnion(currentUser.uid) });
        }
    } catch (error) {
        console.error("Erreur lors du like:", error);
        showNotification("🚫 Erreur lors du like : " + error.message);
    }
}

// Fonctionnalité de suppression de post
async function deletePost(postId, postAuthorUid) {
    if (!currentUser) {
        showNotification("🚫 Vous devez être connecté pour supprimer un post.");
        return;
    }
    // Vérification côté client pour le mot de passe admin (INSÉCURISÉ POUR LA PRODUCTION)
    if (postAuthorUid !== currentUser.uid) {
        const pass = prompt("Mot de passe administrateur requis pour supprimer le post d'un autre utilisateur :");
        if (pass !== ADMIN_PASSWORD) {
            showNotification("🚫 Mot de passe incorrect.");
            return;
        }
    }
    if (!confirm("Confirmer la suppression de ce post et de tous ses commentaires ?")) return;

    try {
        await deleteDoc(doc(db, "devloppement", postId));

        // Supprimer les commentaires associés (NOTE: Ne gère pas efficacement les réponses imbriquées ici,
        // les fonctions Cloud sont recommandées pour les suppressions en cascade)
        const commentsQuery = query(commentsCol, where("postId", "==", postId));
        const commentsSnapshot = await getDocs(commentsQuery);
        const deletePromises = commentsSnapshot.docs.map(doc => deleteDoc(doc.ref));
        await Promise.all(deletePromises);

        showNotification("✅ Post et commentaires supprimés avec succès !");
    } catch (error) {
        console.error("Erreur lors de la suppression du post:", error);
        showNotification("🚫 Erreur lors de la suppression : " + error.message);
    }
}

// Mettre en place un listener en temps réel pour les commentaires sur un post spécifique
function setupCommentsListener(postId) {
    // Se désabonner du listener précédent s'il existe pour éviter les doublons
    if (commentListeners[postId]) {
        commentListeners[postId]();
        delete commentListeners[postId];
    }

    const commentsListContainer = document.getElementById(`comments-list-${postId}`);
    const commentCountSpan = document.getElementById(`comment-count-${postId}`);
    const mainButtonCountSpan = document.getElementById(`comment-count-display-${postId}`);

    if (!commentsListContainer || !commentCountSpan || !mainButtonCountSpan) return;

    commentsListContainer.innerHTML = ''; // Effacer les commentaires existants

    const q = query(
        commentsCol,
        where("postId", "==", postId),
        orderBy("createdAt", "asc")
    );

    // Stocker la fonction de désabonnement pour la gérer plus tard
    commentListeners[postId] = onSnapshot(q, (snapshot) => {
        const allComments = {};
        const rootComments = [];

        snapshot.forEach(doc => {
            const comment = { id: doc.id, ...doc.data() };
            allComments[comment.id] = comment;
            if (!comment.parentId) {
                rootComments.push(comment);
            }
        });

        // Construire récursivement l'arbre de commentaires pour les réponses
        function buildCommentTree(comments) {
            const tree = [];
            // Trier par heure de création
            comments.sort((a, b) => (a.createdAt && b.createdAt) ? a.createdAt.toMillis() - b.createdAt.toMillis() : 0);

            comments.forEach(comment => {
                const children = Object.values(allComments).filter(c => c.parentId === comment.id);
                comment.replies = buildCommentTree(children);
                tree.push(comment);
            });
            return tree;
        }

        const commentTree = buildCommentTree(rootComments);
        commentTree.sort((a, b) => (a.createdAt && b.createdAt) ? a.createdAt.toMillis() - b.createdAt.toMillis() : 0); // Re-trier les commentaires racine

        commentsListContainer.innerHTML = ''; // Effacer avant de repeupler

        if (commentTree.length === 0) {
            commentsListContainer.innerHTML = '<p class="no-comments">Aucun commentaire pour le moment.</p>';
        } else {
            commentTree.forEach(comment => {
                displayComment(comment, commentsListContainer);
            });
        }

        // Mettre à jour les comptes de commentaires
        commentCountSpan.textContent = snapshot.size;
        mainButtonCountSpan.textContent = snapshot.size;

    }, (error) => {
        console.error("Erreur lors de la récupération des commentaires:", error);
        showNotification("🚫 Erreur lors du chargement des commentaires.");
    });
}

// Afficher un seul commentaire (et ses réponses)
function displayComment(comment, parentContainer) {
    const commentItem = document.createElement("div");
    commentItem.className = `comment-item ${comment.parentId ? 'reply' : ''}`;
    commentItem.id = `comment-${comment.id}`;

    const formattedDate = comment.createdAt ?
        new Date(comment.createdAt.toDate()).toLocaleString('fr-FR', {
            day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
        }) : 'Date inconnue';

    let actionButtonsHTML = ``;
    if (currentUser) {
        actionButtonsHTML += `
            <button class="action-btn reply-comment-btn" data-comment-id="${comment.id}" data-post-id="${comment.postId}">
                Répondre
            </button>
        `;
    }
    // Autoriser l'auteur ou l'admin à supprimer le commentaire
    if (currentUser && (currentUser.uid === comment.authorUid || ADMIN_PASSWORD)) { // Vérification admin basique côté client
        actionButtonsHTML += `
            <button class="action-btn delete-comment-btn" data-comment-id="${comment.id}">
                Supprimer
            </button>
        `;
    }

    const authorDisplayName = comment.author || 'Anonyme';
    const authorInitial = getInitials(authorDisplayName);
    const authorPhotoURL = (comment.authorPhotoURL && comment.authorPhotoURL !== 'null') ? comment.authorPhotoURL : `https://via.placeholder.com/40?text=${authorInitial}`;

    let replyToHtml = '';
    if (comment.parentId && comment.parentCommentAuthor) {
        replyToHtml = `<span class="reply-to-text">a répondu à ${comment.parentCommentAuthor}</span>`;
    }

    commentItem.innerHTML = `
        <div class="comment-header">
            <img src="${authorPhotoURL}" alt="Avatar de ${authorDisplayName}" class="comment-avatar">
            <div class="comment-meta">
                <div class="comment-author-name">${authorDisplayName} ${replyToHtml}</div>
                <div class="comment-date">${formattedDate}</div>
            </div>
        </div>
        <div class="comment-content">${comment.content}</div>
        <div class="comment-actions">
            ${actionButtonsHTML}
        </div>
        <div class="reply-form-container" id="reply-form-container-${comment.id}" style="display: none;">
        </div>
        <div class="replies-list-nested" id="replies-list-nested-${comment.id}">
        </div>
    `;
    parentContainer.appendChild(commentItem);

    // Attacher les écouteurs d'événements pour les boutons créés dynamiquement
    commentItem.querySelector('.reply-comment-btn')?.addEventListener('click', toggleReplyForm);
    commentItem.querySelector('.delete-comment-btn')?.addEventListener('click', deleteComment);

    const nestedRepliesList = commentItem.querySelector('.replies-list-nested');
    if (comment.replies && comment.replies.length > 0) {
        comment.replies.forEach(reply => displayComment(reply, nestedRepliesList));
    }
}

// Soumettre un nouveau commentaire ou une réponse
async function submitComment(event) {
    event.preventDefault();

    if (!currentUser) {
        showNotification("🚫 Vous devez être connecté pour commenter.");
        return;
    }

    const form = event.target;
    const postId = form.dataset.postId;
    const parentId = form.dataset.parentId || null;
    const parentAuthor = form.dataset.parentAuthor || null;

    const textarea = form.querySelector('.comment-textarea');
    const commentContent = textarea.value.trim();

    if (!commentContent) {
        showNotification("🚫 Veuillez écrire votre commentaire.");
        return;
    }

    const newComment = {
        postId: postId,
        content: commentContent,
        author: currentUser.displayName || currentUser.email.split('@')[0] || 'Anonyme',
        authorUid: currentUser.uid,
        authorPhotoURL: currentUser.photoURL || null,
        createdAt: serverTimestamp(),
        parentId: parentId
    };

    if (parentId && parentAuthor) {
        newComment.parentCommentAuthor = parentAuthor;
    }

    try {
        await addDoc(commentsCol, newComment);
        showNotification("✅ Commentaire posté !");
        textarea.value = '';
        if (parentId) {
            // Fermer le formulaire de réponse après la soumission
            document.getElementById(`reply-form-container-${parentId}`).style.display = 'none';
        }
    } catch (error) {
        console.error("Erreur lors de l'ajout du commentaire:", error);
        showNotification("🚫 Erreur lors de l'ajout du commentaire : " + error.message);
    }
}

// Basculer la visibilité du formulaire de réponse
function toggleReplyForm(event) {
    if (!currentUser) {
        showNotification("🚫 Vous devez être connecté pour répondre.");
        return;
    }

    const commentId = event.target.dataset.commentId;
    const postId = event.target.dataset.postId;
    const parentCommentAuthorElement = event.target.closest('.comment-item').querySelector('.comment-author-name');
    const parentAuthor = parentCommentAuthorElement ? parentCommentAuthorElement.textContent.split(' ')[0] : 'cet utilisateur';

    const replyFormContainer = document.getElementById(`reply-form-container-${commentId}`);

    // Cacher tous les autres formulaires de réponse si un est ouvert
    document.querySelectorAll('.reply-form-container').forEach(container => {
        if (container.id !== `reply-form-container-${commentId}`) {
            container.style.display = 'none';
            container.innerHTML = ''; // Effacer le contenu lors de la fermeture
        }
    });

    if (replyFormContainer.style.display === 'block') {
        replyFormContainer.style.display = 'none';
        replyFormContainer.innerHTML = '';
    } else {
        replyFormContainer.innerHTML = `
            <form class="comment-form reply-form-actual" data-post-id="${postId}" data-parent-id="${commentId}" data-parent-author="${parentAuthor}">
                <textarea class="comment-textarea" placeholder="Votre réponse à ${parentAuthor}..." required></textarea>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button type="submit" class="btn btn-primary btn-small">Répondre</button>
                    <button type="button" class="btn btn-secondary btn-small cancel-reply-btn">Annuler</button>
                </div>
            </form>
        `;
        replyFormContainer.style.display = 'block';

        const newReplyForm = replyFormContainer.querySelector('.reply-form-actual');
        newReplyForm.addEventListener('submit', submitComment);

        newReplyForm.querySelector('.cancel-reply-btn').addEventListener('click', () => {
            replyFormContainer.style.display = 'none';
            replyFormContainer.innerHTML = '';
        });

        newReplyForm.querySelector('.comment-textarea').focus();
    }
}

// Supprimer un commentaire (et ses réponses directes)
async function deleteComment(event) {
    const commentId = event.target.dataset.commentId;

    if (!currentUser) {
        showNotification("🚫 Vous devez être connecté pour supprimer un commentaire.");
        return;
    }

    try {
        const commentRef = doc(db, "comments", commentId);
        const commentDoc = await getDoc(commentRef);

        if (!commentDoc.exists()) {
            showNotification("🚫 Commentaire introuvable.");
            return;
        }

        const commentData = commentDoc.data();

        // Vérification admin côté client (INSÉCURISÉ POUR LA PRODUCTION)
        if (commentData.authorUid !== currentUser.uid) {
            const pass = prompt("Mot de passe administrateur requis pour supprimer ce commentaire :");
            if (pass !== ADMIN_PASSWORD) {
                showNotification("🚫 Mot de passe incorrect.");
                return;
            }
        }

        if (!confirm("Êtes-vous sûr de vouloir supprimer ce commentaire et toutes ses réponses ?")) {
            return;
        }

        await deleteDoc(commentRef);

        // Supprimer les réponses directes à ce commentaire (la suppression récursive des réponses imbriquées est complexe côté client)
        const repliesToDeleteQuery = query(commentsCol, where("parentId", "==", commentId));
        const repliesSnapshot = await getDocs(repliesToDeleteQuery);
        const deleteRepliesPromises = repliesSnapshot.docs.map(doc => deleteDoc(doc.ref));
        await Promise.all(deleteRepliesPromises);

        showNotification("✅ Commentaire supprimé avec succès !");
    } catch (error) {
        console.error("Erreur lors de la suppression du commentaire:", error);
        showNotification("🚫 Erreur lors de la suppression : " + error.message);
    }
}

// Fonction pour rendre une seule carte de post (utilisée pour le fil principal et l'afficheur de profil)
function renderPostCard(post, containerElement) {
    const postId = post.id;
    let postElement = containerElement.querySelector(`.post-card[data-post-id="${postId}"]`);

    // Si le post existe déjà, le mettre à jour (utile pour onSnapshot pour minimiser les changements DOM)
    if (postElement) {
        // Mettre à jour le contenu si nécessaire (comme les comptes de likes, etc.)
        const likesCount = (post.likes && post.likes.length) ? post.likes.length : 0;
        const hasLiked = currentUser && post.likes && post.likes.includes(currentUser.uid);
        const likeButton = postElement.querySelector('.like-toggle-btn'); // Cible le bouton par sa classe
        if (likeButton) {
            likeButton.className = `btn-small like-btn ${hasLiked ? 'liked' : ''}`;
            likeButton.innerHTML = `<i class="fas fa-heart"></i> ${likesCount} J'aime`;
        }
        return;
    }

    // Si le post n'existe pas, créer un nouvel élément
    postElement = document.createElement("div");
    postElement.className = "post-card";
    postElement.dataset.postId = postId;

    const postDate = post.createdAt ?
        new Date(post.createdAt.toDate()).toLocaleString('fr-FR', {
            year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit'
        }) : (post.date ? new Date(post.date).toLocaleString('fr-FR', {
            year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit'
        }) : 'Date inconnue');

    const isAuthor = currentUser && post.authorUid === currentUser.uid;
    const likesCount = (post.likes && post.likes.length) ? post.likes.length : 0;
    const hasLiked = currentUser && post.likes && post.likes.includes(currentUser.uid);
    const likeButtonClass = `btn-small like-btn ${hasLiked ? 'liked' : ''}`;
    const likeButtonDisabled = !currentUser ? 'disabled' : '';

    const authorDisplayName = post.author || 'Anonyme';
    const authorInitial = getInitials(authorDisplayName);
    const authorPhoto = (post.authorPhotoURL && post.authorPhotoURL !== 'null') ? post.authorPhotoURL : `https://via.placeholder.com/55?text=${authorInitial}`;

    const deleteButton = (isAuthor || (currentUser && currentUser.email === 'votre_email_admin@exemple.com')) ?
        `<button class="btn-small btn-danger delete-post-btn">
            <i class="fas fa-trash"></i> Supprimer
        </button>` : '';

    const commentButtonDisabled = !currentUser ? 'disabled' : '';

    postElement.innerHTML = `
        <div class="post-header">
            <img src="${authorPhoto}" alt="Avatar de ${authorDisplayName}" class="author-avatar">
            <div class="post-meta">
                <div class="post-author">${authorDisplayName}</div>
                <div class="post-date">${postDate}</div>
            </div>
        </div>
        <h3 class="post-title">${post.title}</h3>
        <p class="post-content">${post.content}</p>

        <div class="post-actions">
            <button class="${likeButtonClass} like-toggle-btn" ${likeButtonDisabled}>
                <i class="fas fa-heart"></i> ${likesCount} J'aime
            </button>
            <button class="btn-small btn-info toggle-comments-section-btn" data-post-id="${postId}" ${commentButtonDisabled}>
                <i class="fas fa-comment"></i> Commenter (<span id="comment-count-display-${postId}">0</span>)
            </button>
            ${deleteButton}
        </div>

        <div class="comments-section" id="comments-section-${postId}" style="display: none;">
            <h4 class="comments-title">Commentaires (<span id="comment-count-${postId}">0</span>)</h4>
            <div class="comment-form-main-container">
                <form class="comment-form main-comment-form" data-post-id="${postId}">
                    <textarea class="comment-textarea" placeholder="Ajouter un commentaire..." required ${commentButtonDisabled ? 'disabled' : ''}></textarea>
                    <button type="submit" class="btn comment-submit-btn" ${commentButtonDisabled ? 'disabled' : ''}>Poster</button>
                </form>
            </div>
            <div class="comments-list" id="comments-list-${postId}">
            </div>
        </div>
    `;

    containerElement.prepend(postElement);

    // Attacher les écouteurs d'événements
    postElement.querySelector('.like-toggle-btn')?.addEventListener('click', () => toggleLike(postId));
    postElement.querySelector('.delete-post-btn')?.addEventListener('click', () => deletePost(postId, post.authorUid));

    const toggleCommentsBtn = postElement.querySelector('.toggle-comments-section-btn');
    if (toggleCommentsBtn) {
        toggleCommentsBtn.addEventListener('click', () => {
            const commentsSection = document.getElementById(`comments-section-${postId}`);
            const commentCountOnButton = document.getElementById(`comment-count-display-${postId}`).textContent;
            if (commentsSection.style.display === 'none') {
                commentsSection.style.display = 'block';
                toggleCommentsBtn.innerHTML = `<i class="fas fa-comment"></i> Masquer les commentaires (<span id="comment-count-display-${postId}">${commentCountOnButton}</span>)`;
                commentsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                commentsSection.querySelector('.comment-textarea')?.focus();
            } else {
                commentsSection.style.display = 'none';
                toggleCommentsBtn.innerHTML = `<i class="fas fa-comment"></i> Commenter (<span id="comment-count-display-${postId}">${commentCountOnButton}</span>)`;
            }
        });
    }

    postElement.querySelector('.main-comment-form')?.addEventListener('submit', submitComment);

    // Initialiser le listener de commentaires pour ce post
    setupCommentsListener(postId);
}

// Charger les posts créés par l'utilisateur actuel pour l'afficheur de profil
function loadUserPosts(uid) {
    userPostsContainer.innerHTML = `<p class="loading-message">Chargement de vos publications...</p>`;

    // Se désabonner du listener existant pour cet UID si il y en a un
    if (userPostListeners[uid]) {
        userPostListeners[uid]();
        delete userPostListeners[uid];
    }

    const q = query(postsCol, where("authorUid", "==", uid), orderBy("createdAt", "desc"));

    userPostListeners[uid] = onSnapshot(q, (snapshot) => {
        userPostsContainer.innerHTML = ''; // Effacer le message de chargement

        if (snapshot.empty) {
            userPostsContainer.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-box-open empty-icon"></i>
                    <p>Vous n'avez pas encore publié de posts.</p>
                    <p>Partagez votre première publication !</p>
                </div>
            `;
        } else {
            userPostsContainer.innerHTML = ''; // Effacer les posts existants avant de re-rendre
            snapshot.forEach(doc => {
                renderPostCard(Object.assign({ id: doc.id }, doc.data()), userPostsContainer);
            });
        }
    }, (error) => {
        console.error("Erreur lors du chargement des posts de l'utilisateur:", error);
        userPostsContainer.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-exclamation-triangle empty-icon"></i>
                <p>Erreur lors du chargement de vos posts.</p>
            </div>
        `;
    });
}

// Charger les posts aimés par l'utilisateur actuel pour l'afficheur de profil
function loadUserLikedPosts(uid) {
    userLikesContainer.innerHTML = `<p class="loading-message">Chargement des posts aimés...</p>`;

    // Se désabonner du listener existant pour cet UID si il y en a un
    if (userLikedPostListeners[uid]) {
        userLikedPostListeners[uid]();
        delete userLikedPostListeners[uid];
    }

    const q = query(postsCol, where("likes", "array-contains", uid), orderBy("createdAt", "desc"));

    userLikedPostListeners[uid] = onSnapshot(q, (snapshot) => {
        userLikesContainer.innerHTML = ''; // Effacer le message de chargement

        if (snapshot.empty) {
            userLikesContainer.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-heart-broken empty-icon"></i>
                    <p>Vous n'avez pas encore liké de posts.</p>
                    <p>Explorez et aimez des publications !</p>
                </div>
            `;
        } else {
            userLikesContainer.innerHTML = ''; // Effacer les posts existants avant de re-rendre
            snapshot.forEach(doc => {
                renderPostCard(Object.assign({ id: doc.id }, doc.data()), userLikesContainer);
            });
        }
    }, (error) => {
        console.error("Erreur lors du chargement des posts aimés:", error);
        userLikesContainer.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-exclamation-triangle empty-icon"></i>
                <p>Erreur lors du chargement des posts aimés.</p>
            </div>
        `;
    });
}

// Charger tous les posts pour le fil principal
function loadPosts() {
    postsContainer.innerHTML = `
        <div class="loading">
            <i class="fas fa-spinner fa-spin"></i>
            Chargement des publications...
        </div>
    `;

    const q = query(postsCol, orderBy("createdAt", "desc"));
    getDocs(q).then(querySnapshot => {
        postsContainer.innerHTML = '';

        if (querySnapshot.empty) {
            postsContainer.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-box-open empty-icon"></i>
                    <p>Aucun post trouvé pour le moment.</p>
                    ${currentUser ? '<p>Soyez le premier à partager une publication !</p>' : '<p>Connectez-vous pour pouvoir créer des publications !</p>'}
                </div>
            `;
            return;
        }

        querySnapshot.forEach(doc => {
            renderPostCard(Object.assign({ id: doc.id }, doc.data()), postsContainer);
        });
    }).catch(error => {
        console.error("Erreur lors du chargement des posts :", error);
        postsContainer.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-exclamation-triangle empty-icon"></i>
                <p>Erreur lors du chargement des posts : ${error.message}</p>
                <p>Veuillez réessayer plus tard.</p>
            </div>
        `;
    });
}

// Chargement initial des posts lorsque le script s'exécute
loadPosts();

// --- Fonctionnalités supplémentaires (si vous les aviez) ---
newPostBtn.addEventListener('click', () => {
    if (currentUser) {
        showNotification("Fonctionnalité 'Nouveau Post' à implémenter.");
    } else {
        showNotification("🚫 Connectez-vous pour créer un nouveau post.");
        loginModal.style.display = 'flex';
    }
});
</script>
</body>
</html>
