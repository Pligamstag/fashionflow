<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FashionFlow - Blog</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary: #6366f1;
      --secondary: #8b5cf6;
      --accent: #06b6d4;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --dark: #0f172a;
      --dark-secondary: #1e293b;
      --text-light: #f8fafc;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, var(--dark) 0%, var(--dark-secondary) 100%);
      color: var(--text-light);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    .background-effects {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }

    .bg-circle {
      position: absolute;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
      filter: blur(40px);
      animation: float 6s ease-in-out infinite;
    }

    .bg-circle:nth-child(1) {
      width: 400px;
      height: 400px;
      top: -200px;
      right: -200px;
      animation-delay: 0s;
    }

    .bg-circle:nth-child(2) {
      width: 300px;
      height: 300px;
      bottom: -150px;
      left: -150px;
      animation-delay: 2s;
    }

    .bg-circle:nth-child(3) {
      width: 200px;
      height: 200px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation-delay: 4s;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(180deg); }
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      position: relative;
      z-index: 1;
    }

    .navbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 30px 0;
      margin-bottom: 40px;
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--primary);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo i {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .nav-actions {
      display: flex;
      gap: 15px;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white;
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-light);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .hero {
      text-align: center;
      margin-bottom: 60px;
      padding: 60px 0;
    }

    .hero h1 {
      font-size: 3.5rem;
      font-weight: 800;
      margin-bottom: 20px;
      background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .hero p {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.8);
      max-width: 600px;
      margin: 0 auto;
      line-height: 1.6;
    }

    .posts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 40px;
      flex-wrap: wrap;
      gap: 20px;
    }

    .posts-title {
      font-size: 2rem;
      font-weight: 700;
      color: var(--text-light);
    }

    .search-filter {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .search-box {
      position: relative;
    }

    .search-input {
      padding: 12px 50px 12px 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-light);
      width: 300px;
      backdrop-filter: blur(10px);
      font-size: 0.9rem;
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .search-icon {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      color: rgba(255, 255, 255, 0.5);
    }

    .posts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 30px;
      margin-bottom: 60px;
    }

    .post-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 30px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .post-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
    }

    .post-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .post-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
    }

    .author-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.1rem;
      color: white;
    }

    .post-meta {
      flex: 1;
    }

    .post-author {
      font-weight: 600;
      color: var(--text-light);
      margin-bottom: 5px;
    }

    .post-date {
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.85rem;
    }

    .post-title {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 15px;
      line-height: 1.4;
    }

    .post-content {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      margin-bottom: 25px;
      font-size: 0.95rem;
    }

    .post-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-start;
      flex-wrap: wrap;
    }

    .btn-small {
      padding: 8px 16px;
      font-size: 0.8rem;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.3s ease;
      border: none;
      cursor: pointer;
      text-decoration: none;
    }

    .btn-danger {
      background: rgba(239, 68, 68, 0.1);
      color: #fca5a5;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .btn-danger:hover {
      background: rgba(239, 68, 68, 0.2);
      transform: translateY(-1px);
    }

    .like-btn {
      background: rgba(239, 68, 68, 0.1);
      color: #fca5a5;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .like-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      transform: translateY(-1px);
    }

    .like-btn.liked {
      animation: likeAnimation 0.6s ease;
    }

    @keyframes likeAnimation {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .btn-info {
      background: rgba(6, 182, 212, 0.1);
      color: #67e8f9;
      border: 1px solid rgba(6, 182, 212, 0.3);
    }

    .btn-info:hover {
      background: rgba(6, 182, 212, 0.2);
      transform: translateY(-1px);
    }

    .replies-section {
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 20px;
    }

    .replies-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .replies-count {
      font-weight: 600;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
    }

    .toggle-replies {
      background: rgba(156, 163, 175, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(156, 163, 175, 0.3);
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }

    .toggle-replies:hover {
      background: rgba(156, 163, 175, 0.2);
    }

    .reply-form {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 16px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
    }

    .reply-form.active {
      display: block;
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .reply-input {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      margin-bottom: 12px;
      resize: vertical;
      min-height: 100px;
      font-family: inherit;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      backdrop-filter: blur(10px);
      font-size: 0.95rem;
    }

    .reply-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .reply-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .reply-form-actions {
      display: flex;
      gap: 12px;
    }

    .btn-success {
      background: linear-gradient(135deg, var(--success), #059669);
      color: white;
    }

    .btn-success:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }

    .replies-list {
      display: none;
    }

    .replies-list.active {
      display: block;
      animation: slideDown 0.3s ease;
    }

    .reply-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 12px;
      border-left: 3px solid var(--accent);
      backdrop-filter: blur(10px);
    }

    .reply-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .reply-author {
      font-weight: 600;
      color: #e2e8f0;
      font-size: 0.9rem;
    }

    .reply-date {
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.8rem;
    }

    .reply-content {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      font-size: 0.9rem;
    }

    .empty-state {
      text-align: center;
      padding: 80px 20px;
      color: rgba(255, 255, 255, 0.8);
    }

    .empty-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      opacity: 0.5;
    }

    .liked-users {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 8px;
      font-style: italic;
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 15px;
      }

      .navbar {
        flex-direction: column;
        gap: 15px;
        padding: 20px;
      }

      .posts-grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .post-card {
        padding: 24px;
      }

      .hero h1 {
        font-size: 2.5rem;
      }

      .posts-header {
        flex-direction: column;
        align-items: stretch;
      }

      .search-input {
        width: 100%;
      }

      .post-actions {
        justify-content: stretch;
      }

      .btn-small {
        flex: 1;
        justify-content: center;
      }
    }

    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 60px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 1.1rem;
    }

    .loading i {
      margin-right: 10px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Modal de Connexion -->
<div id="loginModal" style="display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); justify-content: center; align-items: center; z-index: 999;">
  <div style="background: white; padding: 40px; border-radius: 12px; max-width: 400px; width: 100%; position: relative;">
    <h2 style="margin-bottom: 20px;">Connexion</h2>
    <form id="loginForm" style="display: flex; flex-direction: column; gap: 10px;">
      <input id="email" type="email" placeholder="Email" required style="padding: 10px;">
      <input id="password" type="password" placeholder="Mot de passe" required style="padding: 10px;">
      <button type="submit" class="btn btn-primary">Se connecter</button>
    </form>
    <button id="registerBtn" class="btn btn-secondary" style="margin-top: 10px;">Créer un compte</button>
    <button id="googleLoginBtn" class="btn btn-info" style="margin-top: 10px;">Se connecter avec Google</button>
    <button id="cancelLogin" class="btn btn-danger" style="position: absolute; top: 10px; right: 10px;">X</button>
  </div>
</div>
<!-- Modal Modifier Profil -->
<div id="editProfileModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:999;">
  <div style="background:white; padding:30px; border-radius:12px; max-width:400px; width:100%; position:relative;">
    <h3>Modifier le profil</h3>
    <form id="editProfileForm" style="display:flex; flex-direction:column; gap:10px;">
      <input id="displayNameInput" type="text" placeholder="Nouveau nom" style="padding:10px;">
      <!-- Supprime le champ URL, on upload une image -->
      <label for="photoFileInput">Importer une photo de profil :</label>
      <input id="photoFileInput" type="file" accept="image/*" style="padding:10px;">
      <button type="submit" class="btn btn-success">Enregistrer</button>
      <button type="button" id="cancelEditProfile" class="btn btn-danger" style="position:absolute; top:10px; right:10px;">X</button>
    </form>
  </div>
</div>


  <div class="background-effects">
    <div class="bg-circle"></div>
    <div class="bg-circle"></div>
    <div class="bg-circle"></div>
  </div>

  <div class="container">
    <nav class="navbar">
      <a href="#" class="logo">
        <i class="fas fa-blog"></i>
        FashionFlow
      </a>
      <div class="nav-actions">
        <a href="creerunposte.html" class="btn btn-primary">
          <i class="fas fa-plus"></i>
          Nouveau post
        </a>
        <a href="index.html" class="btn btn-secondary">
          <i class="fas fa-home"></i>
          Accueil
        </a>
      </div>
      <div id="userProfile" style="color: white; display: flex; align-items: center; gap: 10px;">
  <!-- Affiché quand l'utilisateur est connecté -->
</div>

<button id="loginBtn" class="btn btn-secondary">Se connecter</button>

    </nav>

    <section class="hero">
      <h1>Blog de Développement</h1>
      <p>Partagez vos idées, découvertes et projets avec la communauté</p>
    </section>

    <div class="posts-header">
      <h2 class="posts-title">Publications récentes</h2>
      <div class="search-filter">
        <div class="search-box">
          <input type="text" class="search-input" placeholder="Rechercher des posts...">
          <i class="fas fa-search search-icon"></i>
        </div>
      </div>
    </div>

    <div id="postsContainer" class="posts-grid">
      <div class="loading">
        <i class="fas fa-spinner"></i>
        Chargement des publications...
      </div>
    </div>
  </div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
        getAuth,
        GoogleAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        signOut,
        onAuthStateChanged,
        updateProfile
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import {
        getFirestore,
        collection,
        doc,
        getDoc,
        updateDoc,
        addDoc,
        deleteDoc,
        query,
        where,
        orderBy,
        getDocs,
        serverTimestamp,
        arrayUnion,
        arrayRemove,
        onSnapshot
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-storage.js";

    const firebaseConfig = {
        apiKey: "AIzaSyAtjlyHBlRQy_C3HomDXLB39j9lGbLAY_Q",
        authDomain: "fashionflow-3db6b.firebaseapp.com",
        projectId: "fashionflow-3db6b",
        storageBucket: "fashionflow-3db6b.appspot.com",
        messagingSenderId: "1073693995934",
        appId: "1:1073693995934:web:9eb28e8f5176faf41edc8f",
        measurementId: "G-P4DP02HQ75"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const postsCol = collection(db, "devloppement");
    const commentsCol = collection(db, "comments");
    const storage = getStorage(app);

    const auth = getAuth();
    let currentUser = null;
    const ADMIN_PASSWORD = "FFLFKSprod"; // À DÉPLACER DANS UNE VARIABLE D'ENVIRONNEMENT OU UN BACKEND SÉCURISÉ EN PRODUCTION ! NE PAS LAISSER EN CLAIR DANS LE CODE CLIENT !

    const postsContainer = document.getElementById("postsContainer");
    const loginModal = document.getElementById("loginModal");
    const loginBtn = document.getElementById("loginBtn");
    const userProfile = document.getElementById("userProfile");
    const googleLoginBtn = document.getElementById('googleLoginBtn');
    const registerBtn = document.getElementById('registerBtn');
    const cancelLogin = document.getElementById('cancelLogin');
    const loginForm = document.getElementById('loginForm');
    const provider = new GoogleAuthProvider();

    const editProfileModal = document.getElementById('editProfileModal');
    const editProfileForm = document.getElementById('editProfileForm');
    const cancelEditProfile = document.getElementById('cancelEditProfile');

    // Store unsubscribe functions for comment listeners
    const commentListeners = {};

    onAuthStateChanged(auth, (user) => {
        if (user) {
            currentUser = user;
            updateUserProfileUI(user);
            loadPosts(); // Load posts only when a user is logged in
        } else {
            // Unsubscribe all active comment listeners when logging out
            for (const postId in commentListeners) {
                if (typeof commentListeners[postId] === 'function') {
                    commentListeners[postId](); // Call the unsubscribe function
                    delete commentListeners[postId];
                }
            }
            currentUser = null;
            postsContainer.innerHTML = '<p class="info-message">Veuillez vous connecter pour voir les posts.</p>';
            updateUserProfileUI(null);
        }
    });

    googleLoginBtn.addEventListener('click', async () => {
        try {
            await signInWithPopup(auth, provider);
            loginModal.style.display = 'none';
            showNotification("✅ Connexion réussie avec Google !");
        } catch (error) {
            console.error("Erreur de connexion Google:", error);
            showNotification("🚫 Erreur de connexion : " + error.message);
        }
    });

    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('email').value.trim();
        const password = document.getElementById('password').value.trim();
        try {
            await signInWithEmailAndPassword(auth, email, password);
            loginModal.style.display = 'none';
            showNotification("✅ Connexion réussie !");
        } catch (error) {
            console.error("Erreur de connexion email/mdp:", error);
            showNotification("🚫 Erreur de connexion : " + error.message);
        }
    });

    registerBtn.addEventListener('click', async () => {
        const email = document.getElementById('email').value.trim();
        const password = document.getElementById('password').value.trim();
        try {
            await createUserWithEmailAndPassword(auth, email, password);
            showNotification("✅ Inscription réussie !");
            loginModal.style.display = 'none';
        } catch (error) {
            console.error("Erreur d'inscription:", error);
            showNotification("🚫 Erreur d'inscription : " + error.message);
        }
    });

    loginBtn.addEventListener('click', () => {
        loginModal.style.display = 'flex';
    });

    cancelLogin.addEventListener('click', () => {
        loginModal.style.display = 'none';
    });

    function updateUserProfileUI(user) {
        if (user) {
            loginBtn.style.display = 'none';
            userProfile.innerHTML = `
                <div class="user-info">
                    <strong>${user.displayName || user.email}</strong>
                    <img src="${user.photoURL || `https://via.placeholder.com/40?text=${getInitials(user.displayName || user.email)}`}" alt="Avatar" class="user-avatar">
                </div>
                <div class="profile-actions">
                    <button id="editProfileBtn" class="btn btn-info">Modifier Profil</button>
                    <button id="logoutBtn" class="btn btn-danger">Déconnexion</button>
                </div>
            `;
            document.getElementById('logoutBtn').addEventListener('click', async () => {
                try {
                    await signOut(auth);
                    showNotification("✅ Déconnexion réussie.");
                } catch (error) {
                    console.error("Erreur de déconnexion:", error);
                    showNotification("🚫 Erreur de déconnexion : " + error.message);
                }
            });
            document.getElementById('editProfileBtn').addEventListener('click', () => {
                editProfileModal.style.display = 'flex';
                document.getElementById('displayNameInput').value = user.displayName || '';
            });
        } else {
            userProfile.innerHTML = '';
            loginBtn.style.display = 'inline-flex';
        }
    }

    function getInitials(name) {
        if (!name) return 'A'; // Retourne 'A' si le nom est vide ou nul
        const parts = name.split(' ');
        if (parts.length > 1) {
            return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
        }
        return parts[0][0] ? parts[0][0].toUpperCase() : 'A'; // Assure qu'on retourne au moins 'A'
    }

    function showNotification(message, duration = 3000) {
        const notificationDiv = document.createElement('div');
        notificationDiv.className = 'notification';
        notificationDiv.textContent = message;
        document.body.appendChild(notificationDiv);
        setTimeout(() => {
            notificationDiv.remove();
        }, duration);
    }

    editProfileForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        if (!auth.currentUser) {
            showNotification("🚫 Vous devez être connecté pour modifier votre profil.");
            return;
        }

        const displayName = document.getElementById('displayNameInput').value.trim();
        const photoFileInput = document.getElementById('photoFileInput');
        const file = photoFileInput.files[0];

        try {
            let photoURL = auth.currentUser.photoURL;
            if (file) {
                const storageRef = ref(storage, `profilePictures/${auth.currentUser.uid}/${file.name}`);
                await uploadBytes(storageRef, file);
                photoURL = await getDownloadURL(storageRef);
            }

            await updateProfile(auth.currentUser, {
                displayName: displayName || null,
                photoURL: photoURL
            });

            showNotification('✅ Profil mis à jour !');
            editProfileModal.style.display = 'none';
            updateUserProfileUI(auth.currentUser);
        } catch (error) {
            console.error("Erreur lors de la mise à jour du profil :", error);
            showNotification("🚫 Erreur lors de la mise à jour du profil : " + error.message);
        }
    });

    cancelEditProfile.addEventListener('click', () => {
        editProfileModal.style.display = 'none';
    });

    async function toggleLike(postId) {
        if (!currentUser) {
            showNotification("🚫 Vous devez être connecté pour liker.");
            return;
        }
        try {
            const postRef = doc(db, "devloppement", postId);
            const postDoc = await getDoc(postRef);
            if (!postDoc.exists()) {
                showNotification("🚫 Post introuvable !");
                return;
            }
            const postData = postDoc.data();
            const currentLikes = postData.likes || [];
            const hasLiked = currentLikes.includes(currentUser.uid);
            if (hasLiked) {
                await updateDoc(postRef, { likes: arrayRemove(currentUser.uid) });
            } else {
                await updateDoc(postRef, { likes: arrayUnion(currentUser.uid) });
            }
        } catch (error) {
            console.error("Erreur lors du like:", error);
            showNotification("🚫 Erreur lors du like : " + error.message);
        }
    }

    async function deletePost(postId, postAuthorUid) {
        if (!currentUser) {
            showNotification("🚫 Vous devez être connecté pour supprimer un post.");
            return;
        }
        // IMPORTANT: For production, this ADMIN_PASSWORD check should be moved to a secure backend/Cloud Function.
        // Relying on a client-side password for admin actions is a security risk.
        if (postAuthorUid !== currentUser.uid) {
            const pass = prompt("Mot de passe administrateur requis pour supprimer le post d'un autre utilisateur :");
            if (pass !== ADMIN_PASSWORD) {
                showNotification("🚫 Mot de passe incorrect.");
                return;
            }
        }
        if (!confirm("Confirmer la suppression de ce post et de tous ses commentaires ?")) return;

        try {
            await deleteDoc(doc(db, "devloppement", postId));

            const commentsQuery = query(commentsCol, where("postId", "==", postId));
            const commentsSnapshot = await getDocs(commentsQuery);
            const deletePromises = commentsSnapshot.docs.map(doc => deleteDoc(doc.ref));
            await Promise.all(deletePromises);

            showNotification("✅ Post et commentaires supprimés avec succès !");
            loadPosts(); // Reload posts to update the UI
        } catch (error) {
            console.error("Erreur lors de la suppression du post:", error);
            showNotification("🚫 Erreur lors de la suppression : " + error.message);
        }
    }

    // Function to update the comment count on the main button
    function updateCommentCountDisplay(postId, count) {
        const displaySpan = document.getElementById(`comment-count-display-${postId}`);
        if (displaySpan) {
            displaySpan.textContent = count;
        }
    }

    function setupCommentsListener(postId) {
        // Unsubscribe from previous listener if it exists
        if (commentListeners[postId]) {
            commentListeners[postId](); // Call the unsubscribe function
            delete commentListeners[postId]; // Remove it from the object
        }

        const commentsListContainer = document.getElementById(`comments-list-${postId}`);
        const commentCountSpan = document.getElementById(`comment-count-${postId}`);
        const mainButtonCountSpan = document.getElementById(`comment-count-display-${postId}`);

        if (!commentsListContainer || !commentCountSpan || !mainButtonCountSpan) return;

        commentsListContainer.innerHTML = ''; // Clear existing comments

        const q = query(
            commentsCol,
            where("postId", "==", postId),
            orderBy("createdAt", "asc")
        );

        // Store the unsubscribe function
        commentListeners[postId] = onSnapshot(q, (snapshot) => {
            const allComments = {};
            const rootComments = [];

            snapshot.forEach(doc => {
                const comment = { id: doc.id, ...doc.data() };
                allComments[comment.id] = comment;
                if (!comment.parentId) {
                    rootComments.push(comment);
                }
            });

            function buildCommentTree(comments) {
                const tree = [];
                // Sort comments at this level before building the tree
                comments.sort((a, b) => (a.createdAt && b.createdAt) ? a.createdAt.toMillis() - b.createdAt.toMillis() : 0);

                comments.forEach(comment => {
                    const children = Object.values(allComments).filter(c => c.parentId === comment.id);
                    comment.replies = buildCommentTree(children);
                    tree.push(comment);
                });
                return tree;
            }

            const commentTree = buildCommentTree(rootComments);
            // Sort top-level comments as well
            commentTree.sort((a, b) => (a.createdAt && b.createdAt) ? a.createdAt.toMillis() - b.createdAt.toMillis() : 0);

            commentsListContainer.innerHTML = ''; // Clear before repopulating

            if (commentTree.length === 0) {
                commentsListContainer.innerHTML = '<p class="no-comments">Aucun commentaire pour le moment.</p>';
            } else {
                commentTree.forEach(comment => {
                    displayComment(comment, commentsListContainer);
                });
            }

            // Update counts
            commentCountSpan.textContent = snapshot.size; // Count in the open section
            mainButtonCountSpan.textContent = snapshot.size; // Count on the main button

        }, (error) => {
            console.error("Erreur lors de la récupération des commentaires:", error);
            showNotification("🚫 Erreur lors du chargement des commentaires.");
        });
    }

    function displayComment(comment, parentContainer) {
        const commentItem = document.createElement("div");
        commentItem.className = `comment-item ${comment.parentId ? 'reply' : ''}`;
        commentItem.id = `comment-${comment.id}`;

        const formattedDate = comment.createdAt ?
            new Date(comment.createdAt.toDate()).toLocaleString('fr-FR', {
                day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
            }) : 'Date inconnue';

        let actionButtonsHTML = `
            <button class="action-btn reply-comment-btn" data-comment-id="${comment.id}" data-post-id="${comment.postId}">
                Répondre
            </button>
        `;
        if (currentUser && currentUser.uid === comment.authorUid) {
            actionButtonsHTML += `
                <button class="action-btn delete-comment-btn" data-comment-id="${comment.id}">
                    Supprimer
                </button>
            `;
        }

        const authorDisplayName = comment.author || 'Anonyme';
        const authorInitial = getInitials(authorDisplayName);
        // Ensure photoURL is not 'null' string before using, otherwise use initials
        const authorPhotoURL = (comment.authorPhotoURL && comment.authorPhotoURL !== 'null') ? comment.authorPhotoURL : `https://via.placeholder.com/40?text=${authorInitial}`;

        let replyToHtml = '';
        if (comment.parentId && comment.parentCommentAuthor) {
            replyToHtml = `<span class="reply-to-text">a répondu à ${comment.parentCommentAuthor}</span>`;
        }

        commentItem.innerHTML = `
            <div class="comment-header">
                <img src="${authorPhotoURL}" alt="Avatar de ${authorDisplayName}" class="comment-avatar">
                <div class="comment-meta">
                    <div class="comment-author-name">${authorDisplayName} ${replyToHtml}</div>
                    <div class="comment-date">${formattedDate}</div>
                </div>
            </div>
            <div class="comment-content">${comment.content}</div>
            <div class="comment-actions">
                ${actionButtonsHTML}
            </div>
            <div class="reply-form-container" id="reply-form-container-${comment.id}" style="display: none;">
            </div>
            <div class="replies-list-nested" id="replies-list-nested-${comment.id}">
            </div>
        `;
        parentContainer.appendChild(commentItem);

        // Attach event listeners using event delegation if possible, or directly if element is specific
        commentItem.querySelector('.reply-comment-btn')?.addEventListener('click', toggleReplyForm);
        commentItem.querySelector('.delete-comment-btn')?.addEventListener('click', deleteComment);

        const nestedRepliesList = commentItem.querySelector('.replies-list-nested');
        if (comment.replies && comment.replies.length > 0) {
            comment.replies.forEach(reply => displayComment(reply, nestedRepliesList));
        }
    }

    async function submitComment(event) {
        event.preventDefault();

        if (!currentUser) {
            showNotification("🚫 Vous devez être connecté pour commenter.");
            return;
        }

        const form = event.target;
        const postId = form.dataset.postId;
        const parentId = form.dataset.parentId || null;
        const parentAuthor = form.dataset.parentAuthor || null; // NEW: Get parent author for replies

        const textarea = form.querySelector('.comment-textarea');
        const commentContent = textarea.value.trim();

        if (!commentContent) {
            showNotification("🚫 Veuillez écrire votre commentaire.");
            return;
        }

        const newComment = {
            postId: postId,
            content: commentContent,
            author: currentUser.displayName || currentUser.email || 'Anonyme',
            authorUid: currentUser.uid,
            // Ensure photoURL is set to null if it's an empty string or undefined
            authorPhotoURL: currentUser.photoURL || null, 
            createdAt: serverTimestamp(),
            parentId: parentId
        };

        // NEW: Add parentCommentAuthor if it's a reply
        if (parentId && parentAuthor) {
            newComment.parentCommentAuthor = parentAuthor;
        }

        try {
            await addDoc(commentsCol, newComment);
            showNotification("✅ Commentaire posté !");
            textarea.value = '';
            if (parentId) {
                // If it's a reply, hide the reply form after submission
                document.getElementById(`reply-form-container-${parentId}`).style.display = 'none';
            }
        } catch (error) {
            console.error("Erreur lors de l'ajout du commentaire:", error);
            showNotification("🚫 Erreur lors de l'ajout du commentaire : " + error.message);
        }
    }

    function toggleReplyForm(event) {
        if (!currentUser) {
            showNotification("🚫 Vous devez être connecté pour répondre.");
            return;
        }

        const commentId = event.target.dataset.commentId;
        const postId = event.target.dataset.postId;
        // NEW: Get the author of the comment being replied to
        const parentAuthor = event.target.closest('.comment-item').querySelector('.comment-author-name').textContent.split(' ')[0]; // Basic way to get first name, improve if needed

        const replyFormContainer = document.getElementById(`reply-form-container-${commentId}`);

        if (replyFormContainer.style.display === 'block') {
            replyFormContainer.style.display = 'none';
            replyFormContainer.innerHTML = ''; // Clear the form when hidden
        } else {
            replyFormContainer.innerHTML = `
                <form class="comment-form reply-form-actual" data-post-id="${postId}" data-parent-id="${commentId}" data-parent-author="${parentAuthor}">
                    <textarea class="comment-textarea" placeholder="Votre réponse à ${parentAuthor}..." required></textarea>
                    <button type="submit" class="btn comment-submit-btn">Répondre</button>
                    <button type="button" class="btn btn-secondary cancel-reply-btn">Annuler</button>
                </form>
            `;
            replyFormContainer.style.display = 'block';

            const newReplyForm = replyFormContainer.querySelector('.reply-form-actual');
            newReplyForm.addEventListener('submit', submitComment);

            newReplyForm.querySelector('.cancel-reply-btn').addEventListener('click', () => {
                replyFormContainer.style.display = 'none';
                replyFormContainer.innerHTML = '';
            });

            newReplyForm.querySelector('.comment-textarea').focus(); // Focus on the textarea
        }
    }

    async function deleteComment(event) {
        if (!confirm("Êtes-vous sûr de vouloir supprimer ce commentaire et toutes ses réponses ?")) {
            return;
        }

        const commentId = event.target.dataset.commentId;

        if (!currentUser) {
            showNotification("🚫 Vous devez être connecté pour supprimer un commentaire.");
            return;
        }

        try {
            const commentRef = doc(db, "comments", commentId);
            const commentDoc = await getDoc(commentRef);

            if (!commentDoc.exists()) {
                showNotification("🚫 Commentaire introuvable.");
                return;
            }

            const commentData = commentDoc.data();

            // IMPORTANT: For production, this ADMIN_PASSWORD check should be moved to a secure backend/Cloud Function.
            if (commentData.authorUid !== currentUser.uid) {
                const pass = prompt("Mot de passe administrateur requis pour supprimer ce commentaire :");
                if (pass !== ADMIN_PASSWORD) {
                    showNotification("🚫 Mot de passe incorrect.");
                    return;
                }
            }

            await deleteDoc(commentRef);

            // This only deletes direct replies. For full cascade deletion of nested replies,
            // a Firebase Cloud Function triggered on comment deletion is the recommended and robust approach.
            const repliesToDeleteQuery = query(commentsCol, where("parentId", "==", commentId));
            const repliesSnapshot = await getDocs(repliesToDeleteQuery);
            const deleteRepliesPromises = repliesSnapshot.docs.map(doc => deleteDoc(doc.ref));
            await Promise.all(deleteRepliesPromises);

            showNotification("✅ Commentaire supprimé avec succès !");
        } catch (error) {
            console.error("Erreur lors de la suppression du commentaire:", error);
            showNotification("🚫 Erreur lors de la suppression : " + error.message);
        }
    }

    async function loadPosts() {
        try {
            const q = query(postsCol, orderBy("createdAt", "desc"));
            const querySnapshot = await getDocs(q);
            const posts = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            postsContainer.innerHTML = ''; // Clear previous posts

            if (posts.length === 0) {
                postsContainer.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-box-open empty-icon"></i>
                        <p>Aucun post trouvé pour le moment.</p>
                        <p>Soyez le premier à partager une publication !</p>
                    </div>
                `;
                return;
            }

            posts.forEach(post => {
                const postElement = document.createElement("div");
                postElement.className = "post-card";
                postElement.dataset.postId = post.id;

                const postDate = post.createdAt ?
                    new Date(post.createdAt.toDate()).toLocaleString('fr-FR', {
                        year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    }) : (post.date ? new Date(post.date).toLocaleString('fr-FR', {
                        year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    }) : 'Date inconnue');

                const isAuthor = currentUser && post.authorUid === currentUser.uid;
                const likesCount = (post.likes && post.likes.length) ? post.likes.length : 0;
                const hasLiked = currentUser && post.likes && post.likes.includes(currentUser.uid);
                const likeButtonClass = `btn-small like-btn ${hasLiked ? 'liked' : ''}`;

                const authorDisplayName = post.author || 'Anonyme';
                const authorInitial = getInitials(authorDisplayName);
                const authorPhoto = (post.authorPhotoURL && post.authorPhotoURL !== 'null') ? post.authorPhotoURL : `https://via.placeholder.com/40?text=${authorInitial}`;

                postElement.innerHTML = `
                    <div class="post-header">
                        <img src="${authorPhoto}" alt="Avatar de ${authorDisplayName}" class="author-avatar">
                        <div class="post-meta">
                            <div class="post-author">${authorDisplayName}</div>
                            <div class="post-date">${postDate}</div>
                        </div>
                    </div>
                    <h3 class="post-title">${post.title}</h3>
                    <p class="post-content">${post.content}</p>

                    <div class="post-actions">
                        <button onclick="toggleLike('${post.id}')" class="${likeButtonClass}">
                            <i class="fas fa-heart"></i> ${likesCount} J'aime
                        </button>
                        <button class="btn-small btn-info toggle-comments-section-btn" data-post-id="${post.id}">
                            <i class="fas fa-comment"></i> Commenter (<span id="comment-count-display-${post.id}">0</span>)
                        </button>
                        ${isAuthor ? `
                          <button onclick="deletePost('${post.id}', '${post.authorUid}')" class="btn-small btn-danger">
                            <i class="fas fa-trash"></i> Supprimer
                          </button>` : ''}
                    </div>

                    <div class="comments-section" id="comments-section-${post.id}" style="display: none;">
                        <h4 class="comments-title">Commentaires (<span id="comment-count-${post.id}">0</span>)</h4>
                        <div class="comment-form-main-container">
                            <form class="comment-form main-comment-form" data-post-id="${post.id}">
                                <textarea class="comment-textarea" placeholder="Ajouter un commentaire..." required></textarea>
                                <button type="submit" class="btn comment-submit-btn">Poster</button>
                            </form>
                        </div>
                        <div class="comments-list" id="comments-list-${post.id}">
                        </div>
                    </div>
                `;
                postsContainer.appendChild(postElement);

                // Attach listener for the main "Commenter" / "Masquer les commentaires" button
                const toggleCommentsBtn = postElement.querySelector('.toggle-comments-section-btn');
                if (toggleCommentsBtn) {
                    toggleCommentsBtn.addEventListener('click', () => {
                        const commentsSection = document.getElementById(`comments-section-${post.id}`);
                        const commentCountOnButton = document.getElementById(`comment-count-display-${post.id}`).textContent; // Get current count
                        if (commentsSection.style.display === 'none') {
                            commentsSection.style.display = 'block';
                            toggleCommentsBtn.innerHTML = `<i class="fas fa-comment"></i> Masquer les commentaires (<span id="comment-count-display-${post.id}">${commentCountOnButton}</span>)`;
                            commentsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            commentsSection.querySelector('.comment-textarea')?.focus();
                        } else {
                            commentsSection.style.display = 'none';
                            toggleCommentsBtn.innerHTML = `<i class="fas fa-comment"></i> Commenter (<span id="comment-count-display-${post.id}">${commentCountOnButton}</span>)`;
                        }
                    });
                }

                // Attach listener for the main comment form
                postElement.querySelector('.main-comment-form')?.addEventListener('submit', submitComment);

                // Initialize comment listener for this post
                setupCommentsListener(post.id);
            });

        } catch (error) {
            console.error("Erreur lors du chargement des posts :", error);
            postsContainer.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-exclamation-triangle empty-icon"></i>
                    <p>Erreur lors du chargement des posts : ${error.message}</p>
                    <p>Veuillez réessayer plus tard.</p>
                </div>
            `;
        }
    }

    // Expose global functions (used in onclick attributes)
    window.toggleLike = toggleLike;
    window.deletePost = deletePost;
    window.toggleReplyForm = toggleReplyForm;
    window.showNotification = showNotification;
</script>
